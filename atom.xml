<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mastering FP and OO with Scala]]></title>
  <link href="http://blog.jaceklaskowski.pl/atom.xml" rel="self"/>
  <link href="http://blog.jaceklaskowski.pl/"/>
  <updated>2014-09-08T09:12:03+02:00</updated>
  <id>http://blog.jaceklaskowski.pl/</id>
  <author>
    <name><![CDATA[Jacek Laskowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JSON in Play Framework With JsValue and Reads]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/09/02/json-in-play-framework-with-jsvalue-and-reads.html"/>
    <updated>2014-09-02T16:00:00+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/09/02/json-in-play-framework-with-jsvalue-and-reads</id>
    <content type="html"><![CDATA[<p>There are many ways to learn <a href="http://www.scala-lang.org/">the Scala programming language</a> and the vast number of libraries for the language. Mine is to use <a href="http://www.scala-sbt.org/">sbt</a> console in a customized project with required dependencies that are automatically downloaded by sbt. All (analysing, downloading, setting up CLASSPATH and such) is handled by the tooling itself not me. Share your approach if it appears smarter.</p>

<p>In this installment, I&rsquo;m presenting a sbt build for learning the JSON API from the <a href="https://www.playframework.com/documentation/2.4.x/ScalaJson">play-json</a> module in the <a href="https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.libs.json.package">play.api.libs.json</a> package in <a href="https://www.playframework.com/">Play Framework 2.4.0-M1</a>.</p>

<!-- more -->


<p>It’s a code-mainly version of the article <a href="https://www.playframework.com/documentation/2.4.x/ScalaJsonInception">JSON Macro Inception</a> from the official documentation of Play Framework.</p>

<p>Start a new activator/sbt project with the following build definition in <code>build.sbt</code>:</p>

<pre><code>scalaVersion := "2.11.2"

val playVersion = "2.4.0-M1"

libraryDependencies += "com.typesafe.play" %% "play-json" % playVersion
</code></pre>

<p>On the command line execute <code>sbt</code> and then, while in the sbt shell, <code>console</code>.</p>

<pre><code>&gt; console
[info] Starting scala interpreter...
[info]
Welcome to Scala version 2.11.2 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_20).
Type in expressions to have them evaluated.
Type :help for more information.
</code></pre>

<p>When you see the above (the Java version might be different depending on your configuration), you’re in an interactive development environment - Scala REPL - with play-json library and Scala 2.11.2. The world of JSON’s (almost) yours!</p>

<p><code>:pa</code> (a shortcut for <code>:paste</code>) enters paste mode so you can copy and paste entire Scala statements.</p>

<pre><code>scala&gt; :pa
// Entering paste mode (ctrl-D to finish)

import play.api.libs.functional.syntax._
import play.api.libs.json._

// Exiting paste mode, now interpreting.

import play.api.libs.functional.syntax._
import play.api.libs.json._

scala&gt; case class Person(name: String, age: Int, lovesChocolate: Boolean)
defined class Person

scala&gt; :pa
// Entering paste mode (ctrl-D to finish)

implicit val personReads = (
  (__ \ 'name).read[String] and
  (__ \ 'age).read[Int] and
  (__ \ 'lovesChocolate).read[Boolean]
)(Person)

// Exiting paste mode, now interpreting.

personReads: play.api.libs.json.Reads[Person] = play.api.libs.json.Reads$$anon$8@5c2b898d

scala&gt; val jsonStr = """{ "name" : "Jacek", "age" : 41, "lovesChocolate": true }"""
jsonStr: String = { "name" : "Jacek", "age" : 41, "lovesChocolate": true }

scala&gt; val json = play.api.libs.json.Json.parse(jsonStr)
json: play.api.libs.json.JsValue = {"name":"Jacek","age":41,"lovesChocolate":true}

scala&gt; val jacek: Person = json
&lt;console&gt;:18: error: type mismatch;
 found   : play.api.libs.json.JsValue
 required: Person
       val jacek: Person = json
                           ^

scala&gt; val jacek: Person = json.as[Person]
jacek: Person = Person(Jacek,41,true)

scala&gt; implicit val personReads = Json.reads[Person]
personReads: play.api.libs.json.Reads[Person] = play.api.libs.json.Reads$$anon$8@5e930aa2
</code></pre>

<p>With the playground you can play with JSON types in Play however you like. Start with the trait <a href="https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.libs.json.JsValue">play.api.libs.json.JsValue</a> and then learn what <a href="https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.libs.json.Reads">play.api.libs.json.Reads[T]</a> offers. They&rsquo;re the cornerstone of the JSON API in Play.</p>

<p>The entire code to paste (<code>:pa</code> or <code>:paste</code> in sbt console) follows. Note the simplifications codenamed <strong>JSON Inception</strong>.</p>

<pre><code>import play.api.libs.json._

case class Person(name: String, age: Int, lovesChocolate: Boolean)

val jsonStr = """{ "name" : "Jacek", "age" : 41, "lovesChocolate": true }"""

val json = play.api.libs.json.Json.parse(jsonStr)

implicit val personReads = Json.reads[Person]

val jacek: Person = json.as[Person]
</code></pre>

<p>Once you’re done, press <code>Ctrl+D</code> twice to exit <code>console</code> and the sbt shell afterwards.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trait Init[Scope] in Sbt]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/07/22/trait-init-scope-in-sbt.html"/>
    <updated>2014-07-22T13:19:54+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/07/22/trait-init-scope-in-sbt</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been my wish to master <a href="http://scala-lang.org/">Scala</a> recently and since I&rsquo;ve been spending more time with <a href="http://www.scala-sbt.org/">sbt</a> I&rsquo;ve made the decision to use one to master the other (in no particular order). There are quite a few sophisticated projects in Scala out there, but sbt is enough for my needs.</p>

<p>In order to pursue my understanding of sbt (and hence Scala itself) I&rsquo;ve been reading the sources that honestly keep surprising me so much often. It&rsquo;s almost every minute when I find myself scratching my head to digest a piece of sbt code. It&rsquo;s akin to when I was reading the source code of <a href="http://clojure.org/">Clojure</a> to learn the language. People can write complicated code and I wouldn&rsquo;t be surprised to hear sbt&rsquo;s sources belong to the category. I don&rsquo;t care, though. I&rsquo;m fine with the complexity hoping the mental pain brings me closer to master Scala.</p>

<p>Today I picked the trait <a href="https://github.com/sbt/sbt/blob/0.13/util/collection/src/main/scala/sbt/Settings.scala#L41">sbt.Init</a> believing it&rsquo;d be an important step in my journey.</p>

<p><strong>NOTE</strong> It becomes feature-complete when the note disappears. Live with the few mistakes for now. Let me know what you think in the Comments section. The site is on GitHub so pull requests are warmly welcome, too. Thanks!</p>

<!-- more -->


<p>There’s the trait <a href="https://github.com/sbt/sbt/blob/0.13/util/collection/src/main/scala/sbt/Settings.scala#L41">sbt.Init</a>. I don’t really know what its purpose is and I hope to find it out after few Scala snippets. There’s just enough hope to master Scala while pursuing my understanding of sbt with the trait.</p>

<h2>Goal</h2>

<p>Create an instance of trait <code>Init[Scope]</code>.</p>

<h2>Solution</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>val init = new Init[Int] {
</span><span class='line'>  def showFullKey: Show[ScopedKey[_]] = Show { (sk: ScopedKey[_]) =&gt; 
</span><span class='line'>    s"${sk.scope}:${sk.key}...${sk.scopedKey}"
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Run <code>sbt</code> and then execute the command <code>consoleProject</code> to open sbt&rsquo;s Scala REPL with all the necessary types of sbt loaded.</p>

<h2>Mental issues encountered</h2>

<ol>
<li><p>I’m far from being able to distinguish easily type parameters, e.g. <code>Scope</code>, in parameterised types, e.g. <code>Init[Scope]</code>, from types themselves. When I see <code>Init[Scope]</code> my Java-trained eyes see <code>Scope</code> type within <code>Init</code> type and although it doesn’t make sense after a moment that’s my initial thought.</p></li>
<li><p>The type constructor <code>Show[ScopedKey[_]]</code> in the return value type of <code>showFullKey</code> is another trait <code>Show</code> that comes with <code>apply</code> that is supposed to return a <code>String</code> instance from <code>ScopedKey[_]</code>. But hey, <code>ScopedKey[_]</code> is another type constructor, and things get more complex for me again. Happily, <code>Show</code> has a companion object with <code>apply</code> method. The story ends as <code>ScopedKey</code> is a final parameterized case class and the function parameter <code>f: T =&gt; String</code> in <code>Show</code> returns a <code>String</code> so I&rsquo;ve just merely followed the types and it <em>happened</em> to work fine. The Scala compiler happy and so am I.</p></li>
</ol>


<h2>Summary</h2>

<p><code>Show</code> is a function type (with <code>apply</code>) that accepts <code>T</code> and returns <code>String</code>. In our case, <code>T</code> is <code>ScopedKey[_]</code> that’s&hellip;well&hellip;it’s yet to be understood.</p>

<h2>consoleProject in sbt</h2>

<p>If you happened to want to see the code in action, execute <code>sbt consoleProject</code> and give the following a try:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// (attribute) key that points at Int value
</span><span class='line'>scala&gt; val number = AttributeKey[Int]("number", "number stringified")
</span><span class='line'>number: sbt.AttributeKey[Int] = number
</span><span class='line'> 
</span><span class='line'>scala&gt; val init = new Init[Int] {
</span><span class='line'>     |   def showFullKey: Show[ScopedKey[_]] = Show { (sk: ScopedKey[_]) =&gt;
</span><span class='line'>     |     s"${sk.scope}:${sk.key}...${sk.scopedKey}"
</span><span class='line'>     |   }
</span><span class='line'>     | }
</span><span class='line'>init: sbt.Init[Int] = $anon$1@1f95802
</span><span class='line'> 
</span><span class='line'>scala&gt; val sfk: Show[init.ScopedKey[_]] = init.showFullKey
</span><span class='line'>sfk: sbt.Show[init.ScopedKey[_]] = sbt.Show$$anon$1@7f54be72
</span><span class='line'>
</span><span class='line'>scala&gt; val s = sfk(init.ScopedKey[Int](scope=5, key=number))
</span><span class='line'>s: String = 5:number...ScopedKey(5,number)</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Contributing to Open Source Projects on GitHub - Cheat Sheet]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/07/08/contributing-to-open-source-projects-on-github-cheat-sheet.html"/>
    <updated>2014-07-08T01:24:32+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/07/08/contributing-to-open-source-projects-on-github-cheat-sheet</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been contributing to many open source projects over the past couple of years and I found <a href="https://github.com/jaceklaskowski">GitHub</a> pleasantly helpful to continue the gig in the years to come. I&rsquo;ve learnt few techniques along the way.</p>

<p>I don&rsquo;t want to keep the techniques for myself so the git/GitHub cheat sheet is supposed to help me remember the commands and others to learn from my mistakes (<em>aka</em> experience). It&rsquo;s so easy on GitHub that I keep wondering why it took me so long to learn it. It must not for you.</p>

<p>Have fun contributing to open source projects as much as I do! <em>Pro publico bono.</em></p>

<p><strong>NOTE</strong> It becomes feature-complete when the note disappears. Live with the few mistakes for now. Let me know what you think in the Comments section. Pull requests are welcome, too. Thanks!</p>

<!-- more -->


<h2>Picking project</h2>

<p>You start your day hunting down the project you want to contribute to. Be adventurous and pick the one you&rsquo;ve always been dreaming about. This might be the day when the dream comes true.</p>

<p>I&rsquo;m more into Scala/sbt lately so I&rsquo;m with projects under control of the project build tool - <a href="http://www.scala-sbt.org/">sbt</a> as I can learn both contributing.</p>

<h2>Cloning project</h2>

<p>Learning a project can take different approaches and reading the source code or just building it and staying on the cutting edge are a few examples.</p>

<p>In the project&rsquo;s repository on GitHub, on the right-hand side, there&rsquo;s this clone URL field. Select the protocol to use (HTTPS or SSH) and click the Copy to clipboard button.</p>

<p>In the terminal, execute the following command:</p>

<pre><code>git clone [clone URL]
</code></pre>

<p>It creates a directory with the project. The sources are yours now, master.</p>

<h2>Forking project</h2>

<p>Your very first step is to fork a project. Forking means creating your own copy of the project. On GitHub it&rsquo;s so easy with the Fork button in the upper-right corner. Click it and select the account you want the fork go.</p>

<p>In the terminal, go to the project&rsquo;s directory and add the repository as a remote repository.</p>

<pre><code>git remote add [remote-name] [clone URL]
</code></pre>

<p>I tend to use my first name for <code>remote-name</code> so I know that my personal repository copy is under <code>jacek</code> nick.</p>

<h2>Branching project</h2>

<p>Developing a change for a project is the real thing. It can be a documentation page, a fix for an issue or whatever else the project holds.</p>

<p>The following command</p>

<pre><code>git checkout -b [branch-name]
</code></pre>

<p>creates and changes your current branch from <code>master</code> (usually) to <code>branch-name</code>. Use <code>wip/</code> in the <code>branch-name</code> to denote that the work is in progress so people can review the changes before they get <em>squashed</em> and merged with the master.</p>

<h2>Committing changes to project</h2>

<p>On a branch, go the following to commit the changes of yours:</p>

<pre><code>git commit -m [commit-message] -a
</code></pre>

<p>There are some strict rules on how to write a proper <code>commit-message</code>. For now, don&rsquo;t worry about it too much. There are tougher things you will have to go through and writing proper commit messages don&rsquo;t belong to that category&hellip;yet. It&rsquo;s more important to get you up to speed with contributing to a project than to do it without mistakes from the day 0.</p>

<h2>Pushing changes to remote repo</h2>

<p>With the changes on the branch committed, it&rsquo;s time to show off on GitHub. Push the changes with the following command:</p>

<pre><code>git push [remote-name] [branch-name]
</code></pre>

<p>Using command completion can save you a lot of typing here. A decent shell like <a href="http://ohmyz.sh/">oh-my-zsh</a> is highly recommended (on Mac OS X at the very least).</p>

<p><code>remote-name</code> is the nick of the remote repository, e.g. <code>jacek</code> while <code>branch-name</code> is the name of the branch you&rsquo;re working on right now.</p>

<h2>Creating pull request on GitHub</h2>

<p>With the changes in the remote repository on GitHub, you should now be able to send a pull request to the original repo.</p>

<p>GitHub shows the Pull Request button when you&rsquo;re changes hit your repository that&rsquo;s a fork of the project. Click the button and fill out the blanks. GitHub uses your commit message as the title that further easies the process.</p>

<p>Click Create and you&rsquo;ve just contributed to the project! Open Source Contributor badge unlocked! Congratulations.</p>

<h2>Squashing changes</h2>

<p>There might be times when your work in progress generates a stream of changes to a branch. It&rsquo;s assumed that the changes are already <code>git add</code>ed and the project maintainers have requested <em>to squash the changes</em> so they ultimately go (aka get merged) to the master as a single change/commit.</p>

<p>Use <code>git rebase -i [branch]</code>:</p>

<pre><code>git rebase -i origin/master
</code></pre>

<p>where <code>origin/master</code> is the name of the <code>master</code> branch of the project you forked and then branched for your changes from the remote <code>origin</code> repository.</p>

<p>Fix any merge issues while rebasing. When fixed, <code>git add</code> the files and <code>git rebase --continue</code> afterwards.</p>

<p>You can always go back to the previous state (before squashing) with <code>git rebase --abort</code>.</p>

<p>Doing squashing is worth the time since merging the changes with the master later on becomes a no-brainer for the project maintainers.</p>

<p>Useful links about git rebase:</p>

<ul>
<li><a href="http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html">squashing commits with rebase</a></li>
<li><a href="https://help.github.com/articles/about-git-rebase">About Git rebase</a></li>
</ul>


<h2>Deleting remote and local branches</h2>

<p>When the work is over and all the changes are merged with the master, you can safely delete remote and local branches.</p>

<p>Once the work gets merged, GitHub asks you to delete the branch. Click the button under the pull request.</p>

<p>Delete the local branch with the command:</p>

<pre><code>git branch -D [branch-name]
</code></pre>

<p>where <code>branch-name</code> is the name of the branch you want to delete.</p>

<p>You should change the branch to some other branch to be able to delete it.</p>

<h2>Maintainers, use &ldquo;Closes #XXX&rdquo; to auto-close pull requests</h2>

<p>It&rsquo;s a feature of GitHub and mostly for project maintainers when they merging pull requests to <code>master</code>.</p>

<p>After you&rsquo;re about to <code>git push</code> your local changes, <code>git commit</code> them and as the last line add <strong>Closes #XXX</strong> where <strong>XXX</strong> is the pull request id. It will auto-close the pull request.</p>

<p>Useful links about the feature:</p>

<ul>
<li><a href="http://blog.spreedly.com/2014/06/24/merge-pull-request-considered-harmful/">&ldquo;Merge pull request&rdquo; Considered Harmful</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculate Profit in Scala With foldLeft]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/06/26/calculate-profit-in-scala-with-foldLeft.html"/>
    <updated>2014-06-26T22:57:00+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/06/26/calculate-profit-in-scala-with-foldLeft</id>
    <content type="html"><![CDATA[<p>With a credit in a foreign currency one may want to hedge to offset the foreign currency getting stronger, and hence increasing the cost of the credit.</p>

<p>Say, you bought 589 CHF when it costed 3.4007 PLN and then 593 for 3.3704. How much would you profit when the price of selling CHF rose to 3.4107 PLN?</p>

<!-- more -->


<p>The question of how much profit you earned with a series of pairs <code>(quantity, price)</code> against a given CHF price can be calculated as follows:</p>

<pre><code>def calculateProfit(series: Seq[(Int, Double)], currentPrice: Double): Double =
  series.foldLeft(0.0) {
    case (acc, (qty, price)) =&gt; acc + (currentPrice - price) * qty
  }

val qtyPriceSeries = Seq((589,3.4007),(593,3.3704))
val currPrice = 3.4107

scala&gt; calculateProfit(qtyPriceSeries, currPrice)
res0: Double = 29.787899999999745
</code></pre>

<p>It gives you ca 30 PLN.</p>

<p>It&rsquo;d be nice to have a series with the date when a given pair was made, and then compare it with other means of gaining profits. A web app developed in <a href="http://www.playframework.com/">Play</a> and deployed to <a href="https://www.heroku.com/">Heroku</a> or <a href="http://www.cloudbees.com/">CloudBees</a> might be of help, wouldn&rsquo;t it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beginner "Guide" to Sbt 0.13 and IntelliJ IDEA 13]]></title>
    <link href="http://blog.jaceklaskowski.pl/2013/12/07/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13.html"/>
    <updated>2013-12-07T16:39:37+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/2013/12/07/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://blog.jaceklaskowski.pl/images/intellij-idea-13-new-logo.png" title="The logo of IntelliJ IDEA 13" > It has not been very long ago when the only way to work with <a href="http://www.scala-sbt.org/">sbt</a> projects in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> was to use the <a href="https://github.com/mpeltonen/sbt-idea">sbt-idea</a> plugin that aimed at <em>&ldquo;creating IntelliJ IDEA project files&rdquo;</em>.</p>

<p><a href="http://www.jetbrains.com/idea/whatsnew/">With the recent release of IntelliJ IDEA 13</a> (build: 133.193,  released: December 3, 2013) it&rsquo;s no longer true - the version comes with built-in sbt support and the support is available in <a href="http://www.jetbrains.com/idea/download/index.html">the free Community Edition</a>, too.</p>

<p>My recent, rather quite frequent visits on <a href="http://stackoverflow.com/">StackOverflow</a> have showed that there&rsquo;s one question very often asked - <strong>How to start using sbt with IntelliJ IDEA?</strong> It turns out that the latest version of IntelliJ IDEA 13 squashed it pretty neatly and the built-in sbt support made the question irrelevant.</p>

<p>Unless it changes, the page remains empty<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. What a surprise, isn&rsquo;t it? I&rsquo;ve always been thinking about writing the best beginner guide and here it is&hellip;at long last!</p>

<p>On to querying <a href="http://stackoverflow.com/questions/tagged/sbt">StackOverflow&rsquo;s #sbt tag</a> for questions about <em>a</em> sbt support in IntelliJ IDEA 13.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>as a kind of placeholder for future tips and tricks<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Much One Ought to Know Eta Expansion]]></title>
    <link href="http://blog.jaceklaskowski.pl/2013/11/23/how-much-one-ought-to-know-eta-expansion.html"/>
    <updated>2013-11-23T22:20:23+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/2013/11/23/how-much-one-ought-to-know-eta-expansion</id>
    <content type="html"><![CDATA[<p>Have you ever wondered how much you should understand the concept of <strong>eta expansion</strong> to master <a href="http://scala-lang.org/">Scala</a>? I have and hence the page in which I&rsquo;m going to collect the wisdom (dug out of Internet) with its applications.</p>

<!-- more -->


<p><strong>NOTE</strong>: The page is supposed to be a Wiki page not a blog post. It&rsquo;s therefore subject to change without notice. When I find out how to use <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a> to power a Wiki-like system, I&rsquo;ll migrate it there right away.</p>

<h2>Eta expansion? Uh, oh, are we in trouble?</h2>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/155655/1305344">What is the difference between a method and a function</a> on StackOverflow:</p>

<blockquote><p>A function is a piece of code that is called by name. It can be passed data to operate on (ie. the parameters) and can optionally return data (the return value).</p>

<p>All data that is passed to a function is explicitly passed.</p>

<p>A method is a piece of code that is called by name that is associated with an object. In most respects it is identical to a function except for two key differences.</p>

<p>1. It is implicitly passed the object for which it was called</p>

<p>2. It is able to operate on data that is contained within the class (remembering that an object is an instance of a class - the class is the definition, the object is an instance of that data)&#8221;</p></blockquote>

<p>Let&rsquo;s start with the following example.</p>

<pre><code>scala&gt; def foo = 5
foo: Int

scala&gt; val f = foo _
f: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>Do you happen to know the name of <em>the (implicit) conversion</em> when the underscore is applied to a method (as if it stood for its parameters) and you eventually end up with a value - <em>a function</em> (that some call <em>a function value</em>)? That&rsquo;s <em>eta expansion</em> which is a means of coercing (converting) methods into functions in Scala.</p>

<p><code>f</code> is a value of <code>() =&gt; Int</code> type or an instance of <code>&lt;function0&gt;</code>. It may have been written as:</p>

<pre><code>scala&gt; def foo() = 5
foo: ()Int
</code></pre>

<p>Almost.</p>

<p>Can you spot the difference between these three definitions: <code>def foo = 5</code> and <code>def foo() = 5</code> and <code>val f = foo _</code>?</p>

<p>In Scala, <strong>a function</strong> is <em>always</em> a (object) value of a function type that&rsquo;s a syntactic sugar for a <code>Function</code> trait, e.g. <code>Int =&gt; Boolean</code> corresponds to Function1[Int, Boolean]. As a value the function value can be assigned to a name, i.e. can be named.</p>

<p>On the other hand, <strong>a method</strong> of a class is <em>always</em> a member of the type the class represents and as such doesn&rsquo;t have its own type. It has a signature, though, e.g. <code>()Int</code> that looks like a function type, e.g. <code>() =&gt; Int</code>.</p>

<p>A method <em>always</em> belongs to an instance of a class yet looks similar to a function signature-wise.</p>

<p>Think of a method, say <code>foo</code>, that accepts a value of a function type.</p>

<pre><code>scala&gt; def foo(bar: () =&gt; Int) = bar()
baz: (bar: () =&gt; Int)Int

scala&gt; object A {
     |   def baz() = 5
     | }
defined module A

scala&gt; foo(A.baz)
res13: Int = 5

scala&gt; val ff = A.baz _
ff: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(ff)
res14: Int = 5
</code></pre>

<p>During compilation the call <code>foo(A.baz)</code> was transformed to a call to a function value that in turn calls the method <code>baz</code> on the <code>A</code> sole object. It may have been written as:</p>

<pre><code>scala&gt; val fv: () =&gt; Int = () =&gt; A.baz()
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res15: Int = 5
</code></pre>

<p>The function value <code>fv</code> is of <code>Function0[Int]</code> type.</p>

<pre><code>scala&gt; val fv: Function0[Int] = new Function0[Int] {
     |   def apply() = A.baz()
     | }
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res17: Int = 5
</code></pre>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/6651099/1305344">When do I have to treat my methods as partially applied functions in Scala?</a> on StackOverflow:</p>

<blockquote><p>You have to write the <code>_</code> whenever the compiler is not explicitly expecting a <code>Function</code> object.</p></blockquote>

<pre><code>scala&gt; def foo(n: Int) = n
foo: (n: Int)Int

scala&gt; val bar = foo
&lt;console&gt;:8: error: missing arguments for method foo;
follow this method with `_' if you want to treat it as a partially applied function
       val bar = foo
                 ^

scala&gt; val bar: Int =&gt; Int = foo
bar: Int =&gt; Int = &lt;function1&gt;
</code></pre>

<h2>Uniform access principle</h2>

<p>Interestingly, uniform access principle makes understanding eta expansion a bit tricker.</p>

<pre><code>scala&gt; object A {
     |   def foo(bar: () =&gt; Int) = 1
     |   def foo(n: Int) = 2
     | }
defined module A

scala&gt; def f() = 4
f: ()Int

scala&gt; def baz() = 4
baz: ()Int
</code></pre>

<p>Guess what happens when you execute <code>A.foo(baz)</code>.</p>

<pre><code>scala&gt; A.foo(baz)
res0: Int = 2
</code></pre>

<p>What about calling <code>A.foo</code> with <code>baz _</code>?</p>

<pre><code>scala&gt; A.foo(baz _)
res1: Int = 1
</code></pre>

<p>Can you explain why? Visit <a href="http://stackoverflow.com/q/17324247/1305344" title="Eta-expansion between methods and functions with overloaded methods in Scala">Eta-expansion between methods and functions with overloaded methods in Scala</a> on StackOverflow for more information.</p>

<p>There&rsquo;s another example that is not easy to explain.</p>

<pre><code>scala&gt; def fm: Map[Int, String] = Map(0 -&gt; "zero")
fm: Map[Int,String]

scala&gt; fm.isInstanceOf[Function1[Int, String]]
res15: Boolean = true

scala&gt; def g: Int =&gt; String = fm
g: Int =&gt; String
</code></pre>

<p>Since <code>fm</code> is of the <code>Map[Int, String]</code> type and <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map">scala.collection.immutable.Map</a> inherits from <a href="http://www.scala-lang.org/api/current/index.html#scala.Function1">scala.Function1</a>, one can assign <code>fm</code> to <code>g</code>. That works fine.</p>

<p>Can you explain why the following sample doesn&rsquo;t work?</p>

<pre><code>scala&gt; def fm(): Map[Int, String] = Map(0 -&gt; "zero")
fm: ()Map[Int,String]

scala&gt; def g: Int =&gt; String = fm
&lt;console&gt;:8: error: type mismatch;
 found   : () =&gt; Map[Int,String]
 required: Int =&gt; String
       def g: Int =&gt; String = fm
                              ^
</code></pre>

<p>Note that <code>fm</code> got merely the brackets and they&rsquo;re indeed equal.</p>

<pre><code>scala&gt; fm() == fm
res16: Boolean = true
</code></pre>

<p>See <a href="https://issues.scala-lang.org/browse/SI-7187">SI-7187 eta expansion should not precede empty application</a>.</p>

<h2>Eta expansion and overloaded methods</h2>

<p>When there&rsquo;s an object of a type with overloaded methods the underscore <code>_</code> may yield different results.</p>

<p>It may resolve to a one-or-more-argument method.</p>

<pre><code>scala&gt; object A {
     |   def foo = 5
     |   def foo(n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res6: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>The underscore insists on specifying the type of a function value when there&rsquo;s ambiguity regarding the method it should be applied to. And it doesn&rsquo;t matter what the order of parameter types in the overloaded methods is.</p>

<pre><code>scala&gt; object A {
     |   def foo(n: Int) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
&lt;console&gt;:9: error: ambiguous reference to overloaded definition,
both method foo in object A of type (n: Int, m: Int)Int
and  method foo in object A of type (n: Int)Int
match expected type ?
              A.foo _
                ^

scala&gt; A.foo _ : ((Int, Int) =&gt; Int)
res5: (Int, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<p>Interestingly, the underscore is more forgiving (regarding the explicit type of the function value) when there are two overloaded methods of which one accepts a single parameter of the type <a href="http://www.scala-lang.org/api/current/scala/AnyRef.html">AnyRef</a>. In such case, the other method - the no-AnyRef method is chosen.</p>

<pre><code>scala&gt; object A {
     |   def foo(a: AnyRef) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res5: (String, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<h2>Use case - Abstracting over arity</h2>

<p>With eta expansion you may forget about the arity of a method.</p>

<pre><code>scala&gt; class A {
     |   def foo(x: Int, y: Int, z: Int) = 5
     | }
defined class A

scala&gt; def bar(x: A) = x.foo _
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>It&rsquo;s certainly far simpler (and still type-safe) than doing it explicitly.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_, _, _)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>When there is another three-argument method in the <code>A</code> class, you&rsquo;d need to specify the parameter types explicitly that makes using the approach even more troublesome.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_: Int, _: Int, _: Int)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<h2>Scala Specification about Eta Expansion</h2>

<p>In <strong>6.26.5 Eta Expansion</strong> <a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a> says:</p>

<blockquote><p>Eta-expansion converts an expression of method type to an equivalent expression
of function type.</p></blockquote>

<p>The section belongs to <strong>6.26 Implicit Conversions</strong> that gives another perspective on what eta expansion is - it&rsquo;s <em>an implicit converstion</em>.</p>

<p>In <strong>6.26 Implicit Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p>Implicit conversions can be applied to expressions whose type does not match their
expected type, to qualifiers in selections, and to unapplied methods.</p></blockquote>

<p>It goes further into when a type is compatible to another.</p>

<blockquote><p>We say, a type T is compatible to a type U if T conforms to U after applying eta-expansion (§6.26.5) and view applications (§7.3).</p></blockquote>

<p>In <strong>6.26.2 Method Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p><strong>Eta Expansion.</strong> Otherwise, if the method is not a constructor, and the expected
type pt is a function type (Ts&#8217;) => T&#8217;, eta-expansion (§6.26.5) is performed on the
expression e.</p></blockquote>

<h2>References (where wisdom came from)</h2>

<ul>
<li><a href="http://gleichmann.wordpress.com/2011/01/09/functional-scala-turning-methods-into-functions/">Functional Scala: Turning Methods into Functions (or WTF is eta expansion?)</a></li>
<li><a href="https://groups.google.com/d/msg/scala-language/FrDJiagB8CY/3NVmhdKe0vgJ">Eta expansion, meet overloading</a></li>
<li><a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a></li>
<li><a href="http://stackoverflow.com/q/17324247/1305344">Eta-expansion between methods and functions with overloaded methods in Scala</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day With scala.List]]></title>
    <link href="http://blog.jaceklaskowski.pl/2013/11/21/day-with-scala-dot-list.html"/>
    <updated>2013-11-21T21:22:12+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/2013/11/21/day-with-scala-dot-list</id>
    <content type="html"><![CDATA[<p>How could you make an use of scala.List&hellip;</p>
]]></content>
  </entry>
  
</feed>
