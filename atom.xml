<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mastering FP and OO with Scala]]></title>
  <link href="http://jaceklaskowski.github.io/atom.xml" rel="self"/>
  <link href="http://jaceklaskowski.github.io/"/>
  <updated>2014-06-27T00:06:51+02:00</updated>
  <id>http://jaceklaskowski.github.io/</id>
  <author>
    <name><![CDATA[Jacek Laskowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Calculate Profit in Scala With foldLeft]]></title>
    <link href="http://jaceklaskowski.github.io/blog/calculate-profit-in-scala-with-foldLeft/"/>
    <updated>2014-06-26T22:57:00+02:00</updated>
    <id>http://jaceklaskowski.github.io/blog/calculate-profit-in-scala-with-foldLeft</id>
    <content type="html"><![CDATA[<p>With a credit in a foreign currency one may want to hedge to offset the foreign currency getting stronger, and hence increasing the cost of the credit.</p>

<p>Say, you bought 589 CHF when it costed 3.4007 PLN and then 593 for 3.3704. How much would you profit when the price of selling CHF rose to 3.4107 PLN?</p>

<!-- more -->


<p>The question of how much profit you earned with a series of pairs <code>(quantity, price)</code> against a given CHF price can be calculated as follows:</p>

<pre><code>def calculateProfit(series: Seq[(Int, Double)], currentPrice: Double): Double =
  series.foldLeft(0.0) {
    case (acc, (qty, price)) =&gt; acc + (currentPrice - price) * qty
  }

val qtyPriceSeries = Seq((589,3.4007),(593,3.3704))
val currPrice = 3.4107

scala&gt; calculateProfit(qtyPriceSeries, currPrice)
res0: Double = 29.787899999999745
</code></pre>

<p>It gives you ca 30 PLN.</p>

<p>It&rsquo;d be nice to have a series with the date when a given pair was made, and then compare it with other means of gaining profits. A web app developed in <a href="http://www.playframework.com/">Play</a> and deployed to <a href="https://www.heroku.com/">Heroku</a> or <a href="http://www.cloudbees.com/">CloudBees</a> might be of help, wouldn&rsquo;t it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beginner "Guide" to Sbt 0.13 and IntelliJ IDEA 13]]></title>
    <link href="http://jaceklaskowski.github.io/blog/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13/"/>
    <updated>2013-12-07T16:39:37+01:00</updated>
    <id>http://jaceklaskowski.github.io/blog/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://jaceklaskowski.github.io/images/intellij-idea-13-new-logo.png" title="The logo of IntelliJ IDEA 13" > It has not been very long ago when the only way to work with <a href="http://www.scala-sbt.org/">sbt</a> projects in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> was to use the <a href="https://github.com/mpeltonen/sbt-idea">sbt-idea</a> plugin that aimed at <em>&ldquo;creating IntelliJ IDEA project files&rdquo;</em>.</p>

<p><a href="http://www.jetbrains.com/idea/whatsnew/">With the recent release of IntelliJ IDEA 13</a> (build: 133.193,  released: December 3, 2013) it&rsquo;s no longer true &ndash; the version comes with built-in sbt support and the support is available in <a href="http://www.jetbrains.com/idea/download/index.html">the free Community Edition</a>, too.</p>

<p>My recent, rather quite frequent visits on <a href="http://stackoverflow.com/">StackOverflow</a> have showed that there&rsquo;s one question very often asked &ndash; <strong>How to start using sbt with IntelliJ IDEA?</strong> It turns out that the latest version of IntelliJ IDEA 13 squashed it pretty neatly and the built-in sbt support made the question irrelevant.</p>

<p>Unless it changes, the page remains empty<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. What a surprise, isn&rsquo;t it? I&rsquo;ve always been thinking about writing the best beginner guide and here it is&hellip;at long last!</p>

<p>On to querying <a href="http://stackoverflow.com/questions/tagged/sbt">StackOverflow&rsquo;s #sbt tag</a> for questions about <em>a</em> sbt support in IntelliJ IDEA 13.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>as a kind of placeholder for future tips and tricks<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Much One Ought to Know Eta Expansion]]></title>
    <link href="http://jaceklaskowski.github.io/blog/how-much-one-ought-to-know-eta-expansion/"/>
    <updated>2013-11-23T22:20:23+01:00</updated>
    <id>http://jaceklaskowski.github.io/blog/how-much-one-ought-to-know-eta-expansion</id>
    <content type="html"><![CDATA[<p>Have you ever wondered how much you should understand the concept of <strong>eta expansion</strong> to master <a href="http://scala-lang.org/">Scala</a>? I have and hence the page in which I&rsquo;m going to collect the wisdom (dug out of Internet) with its applications.</p>

<!-- more -->


<p><strong>NOTE</strong>: The page is supposed to be a Wiki page not a blog post. It&rsquo;s therefore subject to change without notice. When I find out how to use <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a> to power a Wiki-like system, I&rsquo;ll migrate it there right away.</p>

<h2>Eta expansion? Uh, oh, are we in trouble?</h2>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/155655/1305344">What is the difference between a method and a function</a> on StackOverflow:</p>

<blockquote><p>A function is a piece of code that is called by name. It can be passed data to operate on (ie. the parameters) and can optionally return data (the return value).</p>

<p>All data that is passed to a function is explicitly passed.</p>

<p>A method is a piece of code that is called by name that is associated with an object. In most respects it is identical to a function except for two key differences.</p>

<p>1. It is implicitly passed the object for which it was called</p>

<p>2. It is able to operate on data that is contained within the class (remembering that an object is an instance of a class &ndash; the class is the definition, the object is an instance of that data)&#8221;</p></blockquote>

<p>Let&rsquo;s start with the following example.</p>

<pre><code>scala&gt; def foo = 5
foo: Int

scala&gt; val f = foo _
f: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>Do you happen to know the name of <em>the (implicit) conversion</em> when the underscore is applied to a method (as if it stood for its parameters) and you eventually end up with a value &ndash; <em>a function</em> (that some call <em>a function value</em>)? That&rsquo;s <em>eta expansion</em> which is a means of coercing (converting) methods into functions in Scala.</p>

<p><code>f</code> is a value of <code>() =&gt; Int</code> type or an instance of <code>&lt;function0&gt;</code>. It may have been written as:</p>

<pre><code>scala&gt; def foo() = 5
foo: ()Int
</code></pre>

<p>Almost.</p>

<p>Can you spot the difference between these three definitions: <code>def foo = 5</code> and <code>def foo() = 5</code> and <code>val f = foo _</code>?</p>

<p>In Scala, <strong>a function</strong> is <em>always</em> a (object) value of a function type that&rsquo;s a syntactic sugar for a <code>Function</code> trait, e.g. <code>Int =&gt; Boolean</code> corresponds to Function1[Int, Boolean]. As a value the function value can be assigned to a name, i.e. can be named.</p>

<p>On the other hand, <strong>a method</strong> of a class is <em>always</em> a member of the type the class represents and as such doesn&rsquo;t have its own type. It has a signature, though, e.g. <code>()Int</code> that looks like a function type, e.g. <code>() =&gt; Int</code>.</p>

<p>A method <em>always</em> belongs to an instance of a class yet looks similar to a function signature-wise.</p>

<p>Think of a method, say <code>foo</code>, that accepts a value of a function type.</p>

<pre><code>scala&gt; def foo(bar: () =&gt; Int) = bar()
baz: (bar: () =&gt; Int)Int

scala&gt; object A {
     |   def baz() = 5
     | }
defined module A

scala&gt; foo(A.baz)
res13: Int = 5

scala&gt; val ff = A.baz _
ff: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(ff)
res14: Int = 5
</code></pre>

<p>During compilation the call <code>foo(A.baz)</code> was transformed to a call to a function value that in turn calls the method <code>baz</code> on the <code>A</code> sole object. It may have been written as:</p>

<pre><code>scala&gt; val fv: () =&gt; Int = () =&gt; A.baz()
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res15: Int = 5
</code></pre>

<p>The function value <code>fv</code> is of <code>Function0[Int]</code> type.</p>

<pre><code>scala&gt; val fv: Function0[Int] = new Function0[Int] {
     |   def apply() = A.baz()
     | }
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res17: Int = 5
</code></pre>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/6651099/1305344">When do I have to treat my methods as partially applied functions in Scala?</a> on StackOverflow:</p>

<blockquote><p>You have to write the <code>_</code> whenever the compiler is not explicitly expecting a <code>Function</code> object.</p></blockquote>

<pre><code>scala&gt; def foo(n: Int) = n
foo: (n: Int)Int

scala&gt; val bar = foo
&lt;console&gt;:8: error: missing arguments for method foo;
follow this method with `_' if you want to treat it as a partially applied function
       val bar = foo
                 ^

scala&gt; val bar: Int =&gt; Int = foo
bar: Int =&gt; Int = &lt;function1&gt;
</code></pre>

<h2>Uniform access principle</h2>

<p>Interestingly, uniform access principle makes understanding eta expansion a bit tricker.</p>

<pre><code>scala&gt; object A {
     |   def foo(bar: () =&gt; Int) = 1
     |   def foo(n: Int) = 2
     | }
defined module A

scala&gt; def f() = 4
f: ()Int

scala&gt; def baz() = 4
baz: ()Int
</code></pre>

<p>Guess what happens when you execute <code>A.foo(baz)</code>.</p>

<pre><code>scala&gt; A.foo(baz)
res0: Int = 2
</code></pre>

<p>What about calling <code>A.foo</code> with <code>baz _</code>?</p>

<pre><code>scala&gt; A.foo(baz _)
res1: Int = 1
</code></pre>

<p>Can you explain why? Visit <a href="http://stackoverflow.com/q/17324247/1305344" title="Eta-expansion between methods and functions with overloaded methods in Scala">Eta-expansion between methods and functions with overloaded methods in Scala</a> on StackOverflow for more information.</p>

<p>There&rsquo;s another example that is not easy to explain.</p>

<pre><code>scala&gt; def fm: Map[Int, String] = Map(0 -&gt; "zero")
fm: Map[Int,String]

scala&gt; fm.isInstanceOf[Function1[Int, String]]
res15: Boolean = true

scala&gt; def g: Int =&gt; String = fm
g: Int =&gt; String
</code></pre>

<p>Since <code>fm</code> is of the <code>Map[Int, String]</code> type and <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map">scala.collection.immutable.Map</a> inherits from <a href="http://www.scala-lang.org/api/current/index.html#scala.Function1">scala.Function1</a>, one can assign <code>fm</code> to <code>g</code>. That works fine.</p>

<p>Can you explain why the following sample doesn&rsquo;t work?</p>

<pre><code>scala&gt; def fm(): Map[Int, String] = Map(0 -&gt; "zero")
fm: ()Map[Int,String]

scala&gt; def g: Int =&gt; String = fm
&lt;console&gt;:8: error: type mismatch;
 found   : () =&gt; Map[Int,String]
 required: Int =&gt; String
       def g: Int =&gt; String = fm
                              ^
</code></pre>

<p>Note that <code>fm</code> got merely the brackets and they&rsquo;re indeed equal.</p>

<pre><code>scala&gt; fm() == fm
res16: Boolean = true
</code></pre>

<p>See <a href="https://issues.scala-lang.org/browse/SI-7187">SI-7187 eta expansion should not precede empty application</a>.</p>

<h2>Eta expansion and overloaded methods</h2>

<p>When there&rsquo;s an object of a type with overloaded methods the underscore <code>_</code> may yield different results.</p>

<p>It may resolve to a one-or-more-argument method.</p>

<pre><code>scala&gt; object A {
     |   def foo = 5
     |   def foo(n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res6: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>The underscore insists on specifying the type of a function value when there&rsquo;s ambiguity regarding the method it should be applied to. And it doesn&rsquo;t matter what the order of parameter types in the overloaded methods is.</p>

<pre><code>scala&gt; object A {
     |   def foo(n: Int) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
&lt;console&gt;:9: error: ambiguous reference to overloaded definition,
both method foo in object A of type (n: Int, m: Int)Int
and  method foo in object A of type (n: Int)Int
match expected type ?
              A.foo _
                ^

scala&gt; A.foo _ : ((Int, Int) =&gt; Int)
res5: (Int, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<p>Interestingly, the underscore is more forgiving (regarding the explicit type of the function value) when there are two overloaded methods of which one accepts a single parameter of the type <a href="http://www.scala-lang.org/api/current/scala/AnyRef.html">AnyRef</a>. In such case, the other method &ndash; the no-AnyRef method is chosen.</p>

<pre><code>scala&gt; object A {
     |   def foo(a: AnyRef) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res5: (String, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<h2>Use case &ndash; Abstracting over arity</h2>

<p>With eta expansion you may forget about the arity of a method.</p>

<pre><code>scala&gt; class A {
     |   def foo(x: Int, y: Int, z: Int) = 5
     | }
defined class A

scala&gt; def bar(x: A) = x.foo _
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>It&rsquo;s certainly far simpler (and still type-safe) than doing it explicitly.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_, _, _)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>When there is another three-argument method in the <code>A</code> class, you&rsquo;d need to specify the parameter types explicitly that makes using the approach even more troublesome.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_: Int, _: Int, _: Int)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<h2>Scala Specification about Eta Expansion</h2>

<p>In <strong>6.26.5 Eta Expansion</strong> <a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a> says:</p>

<blockquote><p>Eta-expansion converts an expression of method type to an equivalent expression
of function type.</p></blockquote>

<p>The section belongs to <strong>6.26 Implicit Conversions</strong> that gives another perspective on what eta expansion is &ndash; it&rsquo;s <em>an implicit converstion</em>.</p>

<p>In <strong>6.26 Implicit Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p>Implicit conversions can be applied to expressions whose type does not match their
expected type, to qualifiers in selections, and to unapplied methods.</p></blockquote>

<p>It goes further into when a type is compatible to another.</p>

<blockquote><p>We say, a type T is compatible to a type U if T conforms to U after applying eta-expansion (§6.26.5) and view applications (§7.3).</p></blockquote>

<p>In <strong>6.26.2 Method Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p><strong>Eta Expansion.</strong> Otherwise, if the method is not a constructor, and the expected
type pt is a function type (Ts&#8217;) => T&#8217;, eta-expansion (§6.26.5) is performed on the
expression e.</p></blockquote>

<h2>References (where wisdom came from)</h2>

<ul>
<li><a href="http://gleichmann.wordpress.com/2011/01/09/functional-scala-turning-methods-into-functions/">Functional Scala: Turning Methods into Functions (or WTF is eta expansion?)</a></li>
<li><a href="https://groups.google.com/d/msg/scala-language/FrDJiagB8CY/3NVmhdKe0vgJ">Eta expansion, meet overloading</a></li>
<li><a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a></li>
<li><a href="http://stackoverflow.com/q/17324247/1305344">Eta-expansion between methods and functions with overloaded methods in Scala</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day With scala.List]]></title>
    <link href="http://jaceklaskowski.github.io/blog/day-with-scala-dot-list/"/>
    <updated>2013-11-21T21:22:12+01:00</updated>
    <id>http://jaceklaskowski.github.io/blog/day-with-scala-dot-list</id>
    <content type="html"><![CDATA[<p>How could you make an use of scala.List&hellip;</p>
]]></content>
  </entry>
  
</feed>
