<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mastering FP and OO with Scala]]></title>
  <link href="http://blog.jaceklaskowski.pl/atom.xml" rel="self"/>
  <link href="http://blog.jaceklaskowski.pl/"/>
  <updated>2014-07-08T22:49:32+02:00</updated>
  <id>http://blog.jaceklaskowski.pl/</id>
  <author>
    <name><![CDATA[Jacek Laskowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Contributing to Open Source Projects on GitHub - Cheat Sheet]]></title>
    <link href="http://blog.jaceklaskowski.pl/github/2014/07/08/contributing-to-open-source-projects-on-github-cheat-sheet.html"/>
    <updated>2014-07-08T01:24:32+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/github/2014/07/08/contributing-to-open-source-projects-on-github-cheat-sheet</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been contributing to many open source projects over the past couple of years and I found <a href="https://github.com/jaceklaskowski">GitHub</a> pleasantly helpful to continue the gig in the years to come. I&rsquo;ve learnt few techniques along the way.</p>

<p>I don&rsquo;t want to keep the techniques for myself so the git/GitHub cheat sheet is supposed to help me remember the commands and others to learn from my mistakes (<em>aka</em> experience). It&rsquo;s so easy on GitHub that I keep wondering why it took me so long to learn it. It must not for you.</p>

<p>Have fun contributing to open source projects as much as I do! <em>Pro publico bono.</em></p>

<p><strong>NOTE</strong> It becomes feature-complete when the note disappears. Live with the few mistakes for now. Let me know what you think in the Comments section. Pull requests are welcome, too. Thanks!</p>

<!-- more -->


<h2>Picking project</h2>

<p>You start your day hunting down the project you want to contribute to. Be adventurous and pick the one you&rsquo;ve always been dreaming about. This might be the day when the dream comes true.</p>

<p>I&rsquo;m more into Scala/sbt lately so I&rsquo;m with projects under control of the project build tool &ndash; <a href="http://www.scala-sbt.org/">sbt</a> as I can learn both contributing.</p>

<h2>Cloning project</h2>

<p>Learning a project can take different approaches and reading the source code or just building it and staying on the cutting edge are a few examples.</p>

<p>In the project&rsquo;s repository on GitHub, on the right-hand side, there&rsquo;s this clone URL field. Select the protocol to use (HTTPS or SSH) and click the Copy to clipboard button.</p>

<p>In the terminal, execute the following command:</p>

<pre><code>git clone [clone URL]
</code></pre>

<p>It creates a directory with the project. The sources are yours now, master.</p>

<h2>Forking project</h2>

<p>Your very first step is to fork a project. Forking means creating your own copy of the project. On GitHub it&rsquo;s so easy with the Fork button in the upper-right corner. Click it and select the account you want the fork go.</p>

<p>In the terminal, go to the project&rsquo;s directory and add the repository as a remote repository.</p>

<pre><code>git remote add [remote-name] [clone URL]
</code></pre>

<p>I tend to use my first name for <code>remote-name</code> so I know that my personal repository copy is under <code>jacek</code> nick.</p>

<h2>Branching project</h2>

<p>Developing a change for a project is the real thing. It can be a documentation page, a fix for an issue or whatever else the project holds.</p>

<p>The following command</p>

<pre><code>git checkout -b [branch-name]
</code></pre>

<p>creates and changes your current branch from <code>master</code> (usually) to <code>branch-name</code>. Use <code>wip/</code> in the <code>branch-name</code> to denote that the work is in progress so people can review the changes before they get <em>squashed</em> and merged with the master.</p>

<h2>Committing changes to project</h2>

<p>On a branch, go the following to commit the changes of yours:</p>

<pre><code>git commit -m [commit-message] -a
</code></pre>

<p>There are some strict rules on how to write a proper <code>commit-message</code>. For now, don&rsquo;t worry about it too much. There are tougher things you will have to go through and writing proper commit messages don&rsquo;t belong to that category&hellip;yet. It&rsquo;s more important to get you up to speed with contributing to a project than to do it without mistakes from the day 0.</p>

<h2>Pushing changes to remote repo</h2>

<p>With the changes on the branch committed, it&rsquo;s time to show off on GitHub. Push the changes with the following command:</p>

<pre><code>git push [remote-name] [branch-name]
</code></pre>

<p>Using command completion can save you a lot of typing here. A decent shell like <a href="http://ohmyz.sh/">oh-my-zsh</a> is highly recommended (on Mac OS X at the very least).</p>

<p><code>remote-name</code> is the nick of the remote repository, e.g. <code>jacek</code> while <code>branch-name</code> is the name of the branch you&rsquo;re working on right now.</p>

<h2>Creating pull request on GitHub</h2>

<p>With the changes in the remote repository on GitHub, you should now be able to send a pull request to the original repo.</p>

<p>GitHub shows the Pull Request button when you&rsquo;re changes hit your repository that&rsquo;s a fork of the project. Click the button and fill out the blanks. GitHub uses your commit message as the title that further easies the process.</p>

<p>Click Create and you&rsquo;ve just contributed to the project! Open Source Contributor badge unlocked! Congratulations.</p>

<h2>Squashing changes</h2>

<p>There might be times when your work in progress generates a stream of changes to the branch. You may face a request <em>to squash the changes</em> so it goes (aka gets merged) to the master as a single change/commit.</p>

<p>Use <code>git rebase -i</code>:</p>

<pre><code>git rebase -i master
</code></pre>

<p>where <code>master</code> is the name of the master branch of the project you forked and then branched for your changes.</p>

<p>Fix any merge issues while rebasing. When fixed, <code>git add</code> the files and <code>git rebase --continue</code> afterwards.</p>

<p>You can always go back to the previous state (before squashing) with <code>git rebase --abort</code>.</p>

<p>Doing squashing is worth the time since merging the changes with the master later on becomes a no-brainer for the project maintainers.</p>

<p>Useful links about git rebase:
* <a href="http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html">squashing commits with rebase</a>
* <a href="https://help.github.com/articles/about-git-rebase">About Git rebase</a></p>

<h2>Deleting remote and local branches</h2>

<p>When the work is over and all the changes are merged with the master, you can safely delete remote and local branches.</p>

<p>Once the work gets merged, GitHub asks you to delete the branch. Click the button under the pull request.</p>

<p>Delete the local branch with the command:</p>

<pre><code>git branch -D [branch-name]
</code></pre>

<p>where <code>branch-name</code> is the name of the branch you want to delete.</p>

<p>You should change the branch to some other branch to be able to delete it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculate Profit in Scala With foldLeft]]></title>
    <link href="http://blog.jaceklaskowski.pl/scala/2014/06/26/calculate-profit-in-scala-with-foldLeft.html"/>
    <updated>2014-06-26T22:57:00+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/scala/2014/06/26/calculate-profit-in-scala-with-foldLeft</id>
    <content type="html"><![CDATA[<p>With a credit in a foreign currency one may want to hedge to offset the foreign currency getting stronger, and hence increasing the cost of the credit.</p>

<p>Say, you bought 589 CHF when it costed 3.4007 PLN and then 593 for 3.3704. How much would you profit when the price of selling CHF rose to 3.4107 PLN?</p>

<!-- more -->


<p>The question of how much profit you earned with a series of pairs <code>(quantity, price)</code> against a given CHF price can be calculated as follows:</p>

<pre><code>def calculateProfit(series: Seq[(Int, Double)], currentPrice: Double): Double =
  series.foldLeft(0.0) {
    case (acc, (qty, price)) =&gt; acc + (currentPrice - price) * qty
  }

val qtyPriceSeries = Seq((589,3.4007),(593,3.3704))
val currPrice = 3.4107

scala&gt; calculateProfit(qtyPriceSeries, currPrice)
res0: Double = 29.787899999999745
</code></pre>

<p>It gives you ca 30 PLN.</p>

<p>It&rsquo;d be nice to have a series with the date when a given pair was made, and then compare it with other means of gaining profits. A web app developed in <a href="http://www.playframework.com/">Play</a> and deployed to <a href="https://www.heroku.com/">Heroku</a> or <a href="http://www.cloudbees.com/">CloudBees</a> might be of help, wouldn&rsquo;t it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beginner "Guide" to Sbt 0.13 and IntelliJ IDEA 13]]></title>
    <link href="http://blog.jaceklaskowski.pl/scala/sbt/intellij-idea/2013/12/07/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13.html"/>
    <updated>2013-12-07T16:39:37+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/scala/sbt/intellij-idea/2013/12/07/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://blog.jaceklaskowski.pl/images/intellij-idea-13-new-logo.png" title="The logo of IntelliJ IDEA 13" > It has not been very long ago when the only way to work with <a href="http://www.scala-sbt.org/">sbt</a> projects in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> was to use the <a href="https://github.com/mpeltonen/sbt-idea">sbt-idea</a> plugin that aimed at <em>&ldquo;creating IntelliJ IDEA project files&rdquo;</em>.</p>

<p><a href="http://www.jetbrains.com/idea/whatsnew/">With the recent release of IntelliJ IDEA 13</a> (build: 133.193,  released: December 3, 2013) it&rsquo;s no longer true &ndash; the version comes with built-in sbt support and the support is available in <a href="http://www.jetbrains.com/idea/download/index.html">the free Community Edition</a>, too.</p>

<p>My recent, rather quite frequent visits on <a href="http://stackoverflow.com/">StackOverflow</a> have showed that there&rsquo;s one question very often asked &ndash; <strong>How to start using sbt with IntelliJ IDEA?</strong> It turns out that the latest version of IntelliJ IDEA 13 squashed it pretty neatly and the built-in sbt support made the question irrelevant.</p>

<p>Unless it changes, the page remains empty<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. What a surprise, isn&rsquo;t it? I&rsquo;ve always been thinking about writing the best beginner guide and here it is&hellip;at long last!</p>

<p>On to querying <a href="http://stackoverflow.com/questions/tagged/sbt">StackOverflow&rsquo;s #sbt tag</a> for questions about <em>a</em> sbt support in IntelliJ IDEA 13.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>as a kind of placeholder for future tips and tricks<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Much One Ought to Know Eta Expansion]]></title>
    <link href="http://blog.jaceklaskowski.pl/scala/2013/11/23/how-much-one-ought-to-know-eta-expansion.html"/>
    <updated>2013-11-23T22:20:23+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/scala/2013/11/23/how-much-one-ought-to-know-eta-expansion</id>
    <content type="html"><![CDATA[<p>Have you ever wondered how much you should understand the concept of <strong>eta expansion</strong> to master <a href="http://scala-lang.org/">Scala</a>? I have and hence the page in which I&rsquo;m going to collect the wisdom (dug out of Internet) with its applications.</p>

<!-- more -->


<p><strong>NOTE</strong>: The page is supposed to be a Wiki page not a blog post. It&rsquo;s therefore subject to change without notice. When I find out how to use <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a> to power a Wiki-like system, I&rsquo;ll migrate it there right away.</p>

<h2>Eta expansion? Uh, oh, are we in trouble?</h2>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/155655/1305344">What is the difference between a method and a function</a> on StackOverflow:</p>

<blockquote><p>A function is a piece of code that is called by name. It can be passed data to operate on (ie. the parameters) and can optionally return data (the return value).</p>

<p>All data that is passed to a function is explicitly passed.</p>

<p>A method is a piece of code that is called by name that is associated with an object. In most respects it is identical to a function except for two key differences.</p>

<p>1. It is implicitly passed the object for which it was called</p>

<p>2. It is able to operate on data that is contained within the class (remembering that an object is an instance of a class &ndash; the class is the definition, the object is an instance of that data)&#8221;</p></blockquote>

<p>Let&rsquo;s start with the following example.</p>

<pre><code>scala&gt; def foo = 5
foo: Int

scala&gt; val f = foo _
f: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>Do you happen to know the name of <em>the (implicit) conversion</em> when the underscore is applied to a method (as if it stood for its parameters) and you eventually end up with a value &ndash; <em>a function</em> (that some call <em>a function value</em>)? That&rsquo;s <em>eta expansion</em> which is a means of coercing (converting) methods into functions in Scala.</p>

<p><code>f</code> is a value of <code>() =&gt; Int</code> type or an instance of <code>&lt;function0&gt;</code>. It may have been written as:</p>

<pre><code>scala&gt; def foo() = 5
foo: ()Int
</code></pre>

<p>Almost.</p>

<p>Can you spot the difference between these three definitions: <code>def foo = 5</code> and <code>def foo() = 5</code> and <code>val f = foo _</code>?</p>

<p>In Scala, <strong>a function</strong> is <em>always</em> a (object) value of a function type that&rsquo;s a syntactic sugar for a <code>Function</code> trait, e.g. <code>Int =&gt; Boolean</code> corresponds to Function1[Int, Boolean]. As a value the function value can be assigned to a name, i.e. can be named.</p>

<p>On the other hand, <strong>a method</strong> of a class is <em>always</em> a member of the type the class represents and as such doesn&rsquo;t have its own type. It has a signature, though, e.g. <code>()Int</code> that looks like a function type, e.g. <code>() =&gt; Int</code>.</p>

<p>A method <em>always</em> belongs to an instance of a class yet looks similar to a function signature-wise.</p>

<p>Think of a method, say <code>foo</code>, that accepts a value of a function type.</p>

<pre><code>scala&gt; def foo(bar: () =&gt; Int) = bar()
baz: (bar: () =&gt; Int)Int

scala&gt; object A {
     |   def baz() = 5
     | }
defined module A

scala&gt; foo(A.baz)
res13: Int = 5

scala&gt; val ff = A.baz _
ff: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(ff)
res14: Int = 5
</code></pre>

<p>During compilation the call <code>foo(A.baz)</code> was transformed to a call to a function value that in turn calls the method <code>baz</code> on the <code>A</code> sole object. It may have been written as:</p>

<pre><code>scala&gt; val fv: () =&gt; Int = () =&gt; A.baz()
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res15: Int = 5
</code></pre>

<p>The function value <code>fv</code> is of <code>Function0[Int]</code> type.</p>

<pre><code>scala&gt; val fv: Function0[Int] = new Function0[Int] {
     |   def apply() = A.baz()
     | }
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res17: Int = 5
</code></pre>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/6651099/1305344">When do I have to treat my methods as partially applied functions in Scala?</a> on StackOverflow:</p>

<blockquote><p>You have to write the <code>_</code> whenever the compiler is not explicitly expecting a <code>Function</code> object.</p></blockquote>

<pre><code>scala&gt; def foo(n: Int) = n
foo: (n: Int)Int

scala&gt; val bar = foo
&lt;console&gt;:8: error: missing arguments for method foo;
follow this method with `_' if you want to treat it as a partially applied function
       val bar = foo
                 ^

scala&gt; val bar: Int =&gt; Int = foo
bar: Int =&gt; Int = &lt;function1&gt;
</code></pre>

<h2>Uniform access principle</h2>

<p>Interestingly, uniform access principle makes understanding eta expansion a bit tricker.</p>

<pre><code>scala&gt; object A {
     |   def foo(bar: () =&gt; Int) = 1
     |   def foo(n: Int) = 2
     | }
defined module A

scala&gt; def f() = 4
f: ()Int

scala&gt; def baz() = 4
baz: ()Int
</code></pre>

<p>Guess what happens when you execute <code>A.foo(baz)</code>.</p>

<pre><code>scala&gt; A.foo(baz)
res0: Int = 2
</code></pre>

<p>What about calling <code>A.foo</code> with <code>baz _</code>?</p>

<pre><code>scala&gt; A.foo(baz _)
res1: Int = 1
</code></pre>

<p>Can you explain why? Visit <a href="http://stackoverflow.com/q/17324247/1305344" title="Eta-expansion between methods and functions with overloaded methods in Scala">Eta-expansion between methods and functions with overloaded methods in Scala</a> on StackOverflow for more information.</p>

<p>There&rsquo;s another example that is not easy to explain.</p>

<pre><code>scala&gt; def fm: Map[Int, String] = Map(0 -&gt; "zero")
fm: Map[Int,String]

scala&gt; fm.isInstanceOf[Function1[Int, String]]
res15: Boolean = true

scala&gt; def g: Int =&gt; String = fm
g: Int =&gt; String
</code></pre>

<p>Since <code>fm</code> is of the <code>Map[Int, String]</code> type and <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map">scala.collection.immutable.Map</a> inherits from <a href="http://www.scala-lang.org/api/current/index.html#scala.Function1">scala.Function1</a>, one can assign <code>fm</code> to <code>g</code>. That works fine.</p>

<p>Can you explain why the following sample doesn&rsquo;t work?</p>

<pre><code>scala&gt; def fm(): Map[Int, String] = Map(0 -&gt; "zero")
fm: ()Map[Int,String]

scala&gt; def g: Int =&gt; String = fm
&lt;console&gt;:8: error: type mismatch;
 found   : () =&gt; Map[Int,String]
 required: Int =&gt; String
       def g: Int =&gt; String = fm
                              ^
</code></pre>

<p>Note that <code>fm</code> got merely the brackets and they&rsquo;re indeed equal.</p>

<pre><code>scala&gt; fm() == fm
res16: Boolean = true
</code></pre>

<p>See <a href="https://issues.scala-lang.org/browse/SI-7187">SI-7187 eta expansion should not precede empty application</a>.</p>

<h2>Eta expansion and overloaded methods</h2>

<p>When there&rsquo;s an object of a type with overloaded methods the underscore <code>_</code> may yield different results.</p>

<p>It may resolve to a one-or-more-argument method.</p>

<pre><code>scala&gt; object A {
     |   def foo = 5
     |   def foo(n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res6: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>The underscore insists on specifying the type of a function value when there&rsquo;s ambiguity regarding the method it should be applied to. And it doesn&rsquo;t matter what the order of parameter types in the overloaded methods is.</p>

<pre><code>scala&gt; object A {
     |   def foo(n: Int) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
&lt;console&gt;:9: error: ambiguous reference to overloaded definition,
both method foo in object A of type (n: Int, m: Int)Int
and  method foo in object A of type (n: Int)Int
match expected type ?
              A.foo _
                ^

scala&gt; A.foo _ : ((Int, Int) =&gt; Int)
res5: (Int, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<p>Interestingly, the underscore is more forgiving (regarding the explicit type of the function value) when there are two overloaded methods of which one accepts a single parameter of the type <a href="http://www.scala-lang.org/api/current/scala/AnyRef.html">AnyRef</a>. In such case, the other method &ndash; the no-AnyRef method is chosen.</p>

<pre><code>scala&gt; object A {
     |   def foo(a: AnyRef) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res5: (String, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<h2>Use case &ndash; Abstracting over arity</h2>

<p>With eta expansion you may forget about the arity of a method.</p>

<pre><code>scala&gt; class A {
     |   def foo(x: Int, y: Int, z: Int) = 5
     | }
defined class A

scala&gt; def bar(x: A) = x.foo _
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>It&rsquo;s certainly far simpler (and still type-safe) than doing it explicitly.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_, _, _)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>When there is another three-argument method in the <code>A</code> class, you&rsquo;d need to specify the parameter types explicitly that makes using the approach even more troublesome.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_: Int, _: Int, _: Int)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<h2>Scala Specification about Eta Expansion</h2>

<p>In <strong>6.26.5 Eta Expansion</strong> <a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a> says:</p>

<blockquote><p>Eta-expansion converts an expression of method type to an equivalent expression
of function type.</p></blockquote>

<p>The section belongs to <strong>6.26 Implicit Conversions</strong> that gives another perspective on what eta expansion is &ndash; it&rsquo;s <em>an implicit converstion</em>.</p>

<p>In <strong>6.26 Implicit Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p>Implicit conversions can be applied to expressions whose type does not match their
expected type, to qualifiers in selections, and to unapplied methods.</p></blockquote>

<p>It goes further into when a type is compatible to another.</p>

<blockquote><p>We say, a type T is compatible to a type U if T conforms to U after applying eta-expansion (ยง6.26.5) and view applications (ยง7.3).</p></blockquote>

<p>In <strong>6.26.2 Method Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p><strong>Eta Expansion.</strong> Otherwise, if the method is not a constructor, and the expected
type pt is a function type (Ts&#8217;) => T&#8217;, eta-expansion (ยง6.26.5) is performed on the
expression e.</p></blockquote>

<h2>References (where wisdom came from)</h2>

<ul>
<li><a href="http://gleichmann.wordpress.com/2011/01/09/functional-scala-turning-methods-into-functions/">Functional Scala: Turning Methods into Functions (or WTF is eta expansion?)</a></li>
<li><a href="https://groups.google.com/d/msg/scala-language/FrDJiagB8CY/3NVmhdKe0vgJ">Eta expansion, meet overloading</a></li>
<li><a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a></li>
<li><a href="http://stackoverflow.com/q/17324247/1305344">Eta-expansion between methods and functions with overloaded methods in Scala</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day With scala.List]]></title>
    <link href="http://blog.jaceklaskowski.pl/list/2013/11/21/day-with-scala-dot-list.html"/>
    <updated>2013-11-21T21:22:12+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/list/2013/11/21/day-with-scala-dot-list</id>
    <content type="html"><![CDATA[<p>How could you make an use of scala.List&hellip;</p>
]]></content>
  </entry>
  
</feed>
