<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | Mastering FP and OO with Scala]]></title>
  <link href="http://jaceklaskowski.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://jaceklaskowski.github.io/"/>
  <updated>2013-11-24T14:23:37+01:00</updated>
  <id>http://jaceklaskowski.github.io/</id>
  <author>
    <name><![CDATA[Jacek Laskowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Much One Ought to Know Eta Expansion]]></title>
    <link href="http://jaceklaskowski.github.io/blog/how-much-one-ought-to-know-eta-expansion/"/>
    <updated>2013-11-23T22:20:23+01:00</updated>
    <id>http://jaceklaskowski.github.io/blog/how-much-one-ought-to-know-eta-expansion</id>
    <content type="html"><![CDATA[<p>Have you ever wondered how much you should understand the concept of <strong>eta expansion</strong> to master <a href="http://scala-lang.org/">Scala</a>? I have and hence the page in which I&rsquo;m going to collect the wisdom (dug out of Internet) with its applications.</p>

<p><strong>NOTE</strong>: The page is supposed to be a Wiki page not a blog post. It&rsquo;s therefore subject to change without notice. When I find out how to use <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a> to power a Wiki-like system, I&rsquo;ll migrate it there right away.</p>

<h2>Eta expansion? Uh, oh, are we in trouble?</h2>

<p>Let&rsquo;s start with the following example.</p>

<pre><code>scala&gt; def foo = 5
foo: Int

scala&gt; val f = foo _
f: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>Do you happen to know the name of <em>the conversion</em> when the underscore is applied to a method (as if it stood for its parameters) and you eventually end up with a value &ndash; <em>a function</em> (that some call <em>a function value</em>)? That&rsquo;s <em>eta expansion</em> which is a means of coercing methods into functions in Scala.</p>

<p><code>f</code> is a value of <code>() =&gt; Int</code> type or an instance of <code>&lt;function0&gt;</code>. It may have been written as:</p>

<pre><code>scala&gt; def foo() = 5
foo: ()Int
</code></pre>

<p>Can you spot the difference between these three definitions: <code>def foo = 5</code> and <code>def foo() = 5</code> and <code>val f = foo _</code>?</p>

<p>In Scala, <strong>a function</strong> is <em>always</em> a (object) value of a function type that&rsquo;s a syntactic sugar for a Function trait, e.g. <code>Int =&gt; Boolean</code> corresponds to Function1[Int, Boolean]. As a value the function value can be assigned to a name, i.e. can be named.</p>

<p>On the other hand, <strong>a method</strong> of a class is <em>always</em> a member of the type the class represents and as such doesn&rsquo;t have its own type. It has a signature, though, e.g. <code>()Int</code> that looks like a function type, e.g. <code>() =&gt; Int</code>.</p>

<p>A method <em>always</em> belongs to an instance of a class yet looks similar to a function signature-wise.</p>

<p>Think of a method, say <code>foo</code>, that accepts a value of a function type.</p>

<pre><code>scala&gt; def foo(bar: () =&gt; Int) = bar()
baz: (bar: () =&gt; Int)Int

scala&gt; object A {
     |   def baz() = 5
     | }
defined module A

scala&gt; foo(A.baz)
res13: Int = 5

scala&gt; val ff = A.baz _
ff: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(ff)
res14: Int = 5
</code></pre>

<p>During compilation the call <code>foo(A.baz)</code> was transformed to a call to a function value that in turn calls the method <code>baz</code> on the <code>A</code> sole object. It may have been written as:</p>

<pre><code>scala&gt; val fv: () =&gt; Int = () =&gt; A.baz()
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res15: Int = 5
</code></pre>

<p>The function value <code>fv</code> is of <code>Function0[Int]</code> type.</p>

<pre><code>scala&gt; val fv: Function0[Int] = new Function0[Int] {
     |   def apply() = A.baz()
     | }
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res17: Int = 5
</code></pre>

<h2>Eta expansion and overloaded methods?</h2>

<p>When there&rsquo;s an object of a type with overloaded methods the underscore <code>_</code> may yield different results.</p>

<p>It may resolve to a one-or-more-argument method.</p>

<pre><code>scala&gt; object A {
     |   def foo = 5
     |   def foo(n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res6: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>The underscore insists on specifying the type of a function value when there&rsquo;s ambiguity regarding the method it should be applied to. And it doesn&rsquo;t matter what the order of parameter types in the overloaded methods is.</p>

<pre><code>scala&gt; object A {
     |   def foo(n: Int) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
&lt;console&gt;:9: error: ambiguous reference to overloaded definition,
both method foo in object A of type (n: Int, m: Int)Int
and  method foo in object A of type (n: Int)Int
match expected type ?
              A.foo _
                ^

scala&gt; A.foo _ : ((Int, Int) =&gt; Int)
res5: (Int, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<p>Interestingly, the underscore is more forgiving (regarding the explicit type of the function value) when there are two overloaded methods of which one accepts a single parameter of the type <a href="http://www.scala-lang.org/api/current/scala/AnyRef.html">AnyRef</a>. In such case, the other method &ndash; the no-AnyRef method is chosen.</p>

<pre><code>scala&gt; object A {
     |   def foo(a: AnyRef) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res5: (String, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<h2>Use case &ndash; Abstracting over arity</h2>

<p>With eta expansion you may forget about the arity of a method.</p>

<pre><code>scala&gt; class A {
     |   def foo(x: Int, y: Int, z: Int) = 5
     | }
defined class A

scala&gt; def bar(x: A) = x.foo _
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>It&rsquo;s certainly far simpler (and still type-safe) than doing it explicitly.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_, _, _)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>When there is another three-argument method in the <code>A</code> class, you&rsquo;d need to specify the parameter types explicitly that makes using the approach even more troublesome.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_: Int, _: Int, _: Int)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<h2>References (where wisdom came from)</h2>

<ul>
<li><a href="http://gleichmann.wordpress.com/2011/01/09/functional-scala-turning-methods-into-functions/">Functional Scala: Turning Methods into Functions (or WTF is eta expansion?)</a></li>
<li><a href="https://groups.google.com/d/msg/scala-language/FrDJiagB8CY/3NVmhdKe0vgJ">Eta expansion, meet overloading</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
