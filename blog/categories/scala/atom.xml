<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | Mastering FP and OO with Scala]]></title>
  <link href="http://blog.jaceklaskowski.pl/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://blog.jaceklaskowski.pl/"/>
  <updated>2014-09-08T09:12:03+02:00</updated>
  <id>http://blog.jaceklaskowski.pl/</id>
  <author>
    <name><![CDATA[Jacek Laskowski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JSON in Play Framework With JsValue and Reads]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/09/02/json-in-play-framework-with-jsvalue-and-reads.html"/>
    <updated>2014-09-02T16:00:00+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/09/02/json-in-play-framework-with-jsvalue-and-reads</id>
    <content type="html"><![CDATA[<p>There are many ways to learn <a href="http://www.scala-lang.org/">the Scala programming language</a> and the vast number of libraries for the language. Mine is to use <a href="http://www.scala-sbt.org/">sbt</a> console in a customized project with required dependencies that are automatically downloaded by sbt. All (analysing, downloading, setting up CLASSPATH and such) is handled by the tooling itself not me. Share your approach if it appears smarter.</p>

<p>In this installment, I&rsquo;m presenting a sbt build for learning the JSON API from the <a href="https://www.playframework.com/documentation/2.4.x/ScalaJson">play-json</a> module in the <a href="https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.libs.json.package">play.api.libs.json</a> package in <a href="https://www.playframework.com/">Play Framework 2.4.0-M1</a>.</p>

<!-- more -->


<p>It’s a code-mainly version of the article <a href="https://www.playframework.com/documentation/2.4.x/ScalaJsonInception">JSON Macro Inception</a> from the official documentation of Play Framework.</p>

<p>Start a new activator/sbt project with the following build definition in <code>build.sbt</code>:</p>

<pre><code>scalaVersion := "2.11.2"

val playVersion = "2.4.0-M1"

libraryDependencies += "com.typesafe.play" %% "play-json" % playVersion
</code></pre>

<p>On the command line execute <code>sbt</code> and then, while in the sbt shell, <code>console</code>.</p>

<pre><code>&gt; console
[info] Starting scala interpreter...
[info]
Welcome to Scala version 2.11.2 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_20).
Type in expressions to have them evaluated.
Type :help for more information.
</code></pre>

<p>When you see the above (the Java version might be different depending on your configuration), you’re in an interactive development environment - Scala REPL - with play-json library and Scala 2.11.2. The world of JSON’s (almost) yours!</p>

<p><code>:pa</code> (a shortcut for <code>:paste</code>) enters paste mode so you can copy and paste entire Scala statements.</p>

<pre><code>scala&gt; :pa
// Entering paste mode (ctrl-D to finish)

import play.api.libs.functional.syntax._
import play.api.libs.json._

// Exiting paste mode, now interpreting.

import play.api.libs.functional.syntax._
import play.api.libs.json._

scala&gt; case class Person(name: String, age: Int, lovesChocolate: Boolean)
defined class Person

scala&gt; :pa
// Entering paste mode (ctrl-D to finish)

implicit val personReads = (
  (__ \ 'name).read[String] and
  (__ \ 'age).read[Int] and
  (__ \ 'lovesChocolate).read[Boolean]
)(Person)

// Exiting paste mode, now interpreting.

personReads: play.api.libs.json.Reads[Person] = play.api.libs.json.Reads$$anon$8@5c2b898d

scala&gt; val jsonStr = """{ "name" : "Jacek", "age" : 41, "lovesChocolate": true }"""
jsonStr: String = { "name" : "Jacek", "age" : 41, "lovesChocolate": true }

scala&gt; val json = play.api.libs.json.Json.parse(jsonStr)
json: play.api.libs.json.JsValue = {"name":"Jacek","age":41,"lovesChocolate":true}

scala&gt; val jacek: Person = json
&lt;console&gt;:18: error: type mismatch;
 found   : play.api.libs.json.JsValue
 required: Person
       val jacek: Person = json
                           ^

scala&gt; val jacek: Person = json.as[Person]
jacek: Person = Person(Jacek,41,true)

scala&gt; implicit val personReads = Json.reads[Person]
personReads: play.api.libs.json.Reads[Person] = play.api.libs.json.Reads$$anon$8@5e930aa2
</code></pre>

<p>With the playground you can play with JSON types in Play however you like. Start with the trait <a href="https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.libs.json.JsValue">play.api.libs.json.JsValue</a> and then learn what <a href="https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.libs.json.Reads">play.api.libs.json.Reads[T]</a> offers. They&rsquo;re the cornerstone of the JSON API in Play.</p>

<p>The entire code to paste (<code>:pa</code> or <code>:paste</code> in sbt console) follows. Note the simplifications codenamed <strong>JSON Inception</strong>.</p>

<pre><code>import play.api.libs.json._

case class Person(name: String, age: Int, lovesChocolate: Boolean)

val jsonStr = """{ "name" : "Jacek", "age" : 41, "lovesChocolate": true }"""

val json = play.api.libs.json.Json.parse(jsonStr)

implicit val personReads = Json.reads[Person]

val jacek: Person = json.as[Person]
</code></pre>

<p>Once you’re done, press <code>Ctrl+D</code> twice to exit <code>console</code> and the sbt shell afterwards.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trait Init[Scope] in Sbt]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/07/22/trait-init-scope-in-sbt.html"/>
    <updated>2014-07-22T13:19:54+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/07/22/trait-init-scope-in-sbt</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been my wish to master <a href="http://scala-lang.org/">Scala</a> recently and since I&rsquo;ve been spending more time with <a href="http://www.scala-sbt.org/">sbt</a> I&rsquo;ve made the decision to use one to master the other (in no particular order). There are quite a few sophisticated projects in Scala out there, but sbt is enough for my needs.</p>

<p>In order to pursue my understanding of sbt (and hence Scala itself) I&rsquo;ve been reading the sources that honestly keep surprising me so much often. It&rsquo;s almost every minute when I find myself scratching my head to digest a piece of sbt code. It&rsquo;s akin to when I was reading the source code of <a href="http://clojure.org/">Clojure</a> to learn the language. People can write complicated code and I wouldn&rsquo;t be surprised to hear sbt&rsquo;s sources belong to the category. I don&rsquo;t care, though. I&rsquo;m fine with the complexity hoping the mental pain brings me closer to master Scala.</p>

<p>Today I picked the trait <a href="https://github.com/sbt/sbt/blob/0.13/util/collection/src/main/scala/sbt/Settings.scala#L41">sbt.Init</a> believing it&rsquo;d be an important step in my journey.</p>

<p><strong>NOTE</strong> It becomes feature-complete when the note disappears. Live with the few mistakes for now. Let me know what you think in the Comments section. The site is on GitHub so pull requests are warmly welcome, too. Thanks!</p>

<!-- more -->


<p>There’s the trait <a href="https://github.com/sbt/sbt/blob/0.13/util/collection/src/main/scala/sbt/Settings.scala#L41">sbt.Init</a>. I don’t really know what its purpose is and I hope to find it out after few Scala snippets. There’s just enough hope to master Scala while pursuing my understanding of sbt with the trait.</p>

<h2>Goal</h2>

<p>Create an instance of trait <code>Init[Scope]</code>.</p>

<h2>Solution</h2>

<pre><code>val init = new Init[Int] {
  def showFullKey: Show[ScopedKey[_]] = Show { (sk: ScopedKey[_]) =&gt; 
    s"${sk.scope}:${sk.key}...${sk.scopedKey}"
  }
}
</code></pre>

<p>Run <code>sbt</code> and then execute the command <code>consoleProject</code> to open sbt&rsquo;s Scala REPL with all the necessary types of sbt loaded.</p>

<h2>Mental issues encountered</h2>

<ol>
<li><p>I’m far from being able to distinguish easily type parameters, e.g. <code>Scope</code>, in parameterised types, e.g. <code>Init[Scope]</code>, from types themselves. When I see <code>Init[Scope]</code> my Java-trained eyes see <code>Scope</code> type within <code>Init</code> type and although it doesn’t make sense after a moment that’s my initial thought.</p></li>
<li><p>The type constructor <code>Show[ScopedKey[_]]</code> in the return value type of <code>showFullKey</code> is another trait <code>Show</code> that comes with <code>apply</code> that is supposed to return a <code>String</code> instance from <code>ScopedKey[_]</code>. But hey, <code>ScopedKey[_]</code> is another type constructor, and things get more complex for me again. Happily, <code>Show</code> has a companion object with <code>apply</code> method. The story ends as <code>ScopedKey</code> is a final parameterized case class and the function parameter <code>f: T =&gt; String</code> in <code>Show</code> returns a <code>String</code> so I&rsquo;ve just merely followed the types and it <em>happened</em> to work fine. The Scala compiler happy and so am I.</p></li>
</ol>


<h2>Summary</h2>

<p><code>Show</code> is a function type (with <code>apply</code>) that accepts <code>T</code> and returns <code>String</code>. In our case, <code>T</code> is <code>ScopedKey[_]</code> that’s&hellip;well&hellip;it’s yet to be understood.</p>

<h2>consoleProject in sbt</h2>

<p>If you happened to want to see the code in action, execute <code>sbt consoleProject</code> and give the following a try:
&#8220;`
// (attribute) key that points at Int value
scala> val number = AttributeKey<a href="" title="number&quot;, &quot;number stringified">Int</a>
number: sbt.AttributeKey[Int] = number</p>

<p>scala> val init = new Init[Int] {
     |   def showFullKey: Show[ScopedKey[<em>]] = Show { (sk: ScopedKey[</em>]) =>
     |     s&#8221;${sk.scope}:${sk.key}&hellip;${sk.scopedKey}&ldquo;
     |   }
     | }
init: sbt.Init[Int] = $anon$1@1f95802</p>

<p>scala> val sfk: Show[init.ScopedKey[<em>]] = init.showFullKey
sfk: sbt.Show[init.ScopedKey[</em>]] = sbt.Show$$anon$1@7f54be72</p>

<p>scala> val s = sfk(init.ScopedKey<a href="scope=5,%20key=number">Int</a>)
s: String = 5:number&hellip;ScopedKey(5,number)
&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculate Profit in Scala With foldLeft]]></title>
    <link href="http://blog.jaceklaskowski.pl/2014/06/26/calculate-profit-in-scala-with-foldLeft.html"/>
    <updated>2014-06-26T22:57:00+02:00</updated>
    <id>http://blog.jaceklaskowski.pl/2014/06/26/calculate-profit-in-scala-with-foldLeft</id>
    <content type="html"><![CDATA[<p>With a credit in a foreign currency one may want to hedge to offset the foreign currency getting stronger, and hence increasing the cost of the credit.</p>

<p>Say, you bought 589 CHF when it costed 3.4007 PLN and then 593 for 3.3704. How much would you profit when the price of selling CHF rose to 3.4107 PLN?</p>

<!-- more -->


<p>The question of how much profit you earned with a series of pairs <code>(quantity, price)</code> against a given CHF price can be calculated as follows:</p>

<pre><code>def calculateProfit(series: Seq[(Int, Double)], currentPrice: Double): Double =
  series.foldLeft(0.0) {
    case (acc, (qty, price)) =&gt; acc + (currentPrice - price) * qty
  }

val qtyPriceSeries = Seq((589,3.4007),(593,3.3704))
val currPrice = 3.4107

scala&gt; calculateProfit(qtyPriceSeries, currPrice)
res0: Double = 29.787899999999745
</code></pre>

<p>It gives you ca 30 PLN.</p>

<p>It&rsquo;d be nice to have a series with the date when a given pair was made, and then compare it with other means of gaining profits. A web app developed in <a href="http://www.playframework.com/">Play</a> and deployed to <a href="https://www.heroku.com/">Heroku</a> or <a href="http://www.cloudbees.com/">CloudBees</a> might be of help, wouldn&rsquo;t it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beginner "Guide" to Sbt 0.13 and IntelliJ IDEA 13]]></title>
    <link href="http://blog.jaceklaskowski.pl/2013/12/07/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13.html"/>
    <updated>2013-12-07T16:39:37+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/2013/12/07/beginner-guide-to-sbt-0-dot-13-and-intellij-idea-13</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/intellij-idea-13-new-logo.png" title="The logo of IntelliJ IDEA 13" > It has not been very long ago when the only way to work with <a href="http://www.scala-sbt.org/">sbt</a> projects in <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> was to use the <a href="https://github.com/mpeltonen/sbt-idea">sbt-idea</a> plugin that aimed at <em>&ldquo;creating IntelliJ IDEA project files&rdquo;</em>.</p>

<p><a href="http://www.jetbrains.com/idea/whatsnew/">With the recent release of IntelliJ IDEA 13</a> (build: 133.193,  released: December 3, 2013) it&rsquo;s no longer true - the version comes with built-in sbt support and the support is available in <a href="http://www.jetbrains.com/idea/download/index.html">the free Community Edition</a>, too.</p>

<p>My recent, rather quite frequent visits on <a href="http://stackoverflow.com/">StackOverflow</a> have showed that there&rsquo;s one question very often asked - <strong>How to start using sbt with IntelliJ IDEA?</strong> It turns out that the latest version of IntelliJ IDEA 13 squashed it pretty neatly and the built-in sbt support made the question irrelevant.</p>

<p>Unless it changes, the page remains empty<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. What a surprise, isn&rsquo;t it? I&rsquo;ve always been thinking about writing the best beginner guide and here it is&hellip;at long last!</p>

<p>On to querying <a href="http://stackoverflow.com/questions/tagged/sbt">StackOverflow&rsquo;s #sbt tag</a> for questions about <em>a</em> sbt support in IntelliJ IDEA 13.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>as a kind of placeholder for future tips and tricks<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Much One Ought to Know Eta Expansion]]></title>
    <link href="http://blog.jaceklaskowski.pl/2013/11/23/how-much-one-ought-to-know-eta-expansion.html"/>
    <updated>2013-11-23T22:20:23+01:00</updated>
    <id>http://blog.jaceklaskowski.pl/2013/11/23/how-much-one-ought-to-know-eta-expansion</id>
    <content type="html"><![CDATA[<p>Have you ever wondered how much you should understand the concept of <strong>eta expansion</strong> to master <a href="http://scala-lang.org/">Scala</a>? I have and hence the page in which I&rsquo;m going to collect the wisdom (dug out of Internet) with its applications.</p>

<!-- more -->


<p><strong>NOTE</strong>: The page is supposed to be a Wiki page not a blog post. It&rsquo;s therefore subject to change without notice. When I find out how to use <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a> to power a Wiki-like system, I&rsquo;ll migrate it there right away.</p>

<h2>Eta expansion? Uh, oh, are we in trouble?</h2>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/155655/1305344">What is the difference between a method and a function</a> on StackOverflow:</p>

<blockquote><p>A function is a piece of code that is called by name. It can be passed data to operate on (ie. the parameters) and can optionally return data (the return value).</p>

<p>All data that is passed to a function is explicitly passed.</p>

<p>A method is a piece of code that is called by name that is associated with an object. In most respects it is identical to a function except for two key differences.</p>

<p>1. It is implicitly passed the object for which it was called</p>

<p>2. It is able to operate on data that is contained within the class (remembering that an object is an instance of a class - the class is the definition, the object is an instance of that data)&#8221;</p></blockquote>

<p>Let&rsquo;s start with the following example.</p>

<pre><code>scala&gt; def foo = 5
foo: Int

scala&gt; val f = foo _
f: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>Do you happen to know the name of <em>the (implicit) conversion</em> when the underscore is applied to a method (as if it stood for its parameters) and you eventually end up with a value - <em>a function</em> (that some call <em>a function value</em>)? That&rsquo;s <em>eta expansion</em> which is a means of coercing (converting) methods into functions in Scala.</p>

<p><code>f</code> is a value of <code>() =&gt; Int</code> type or an instance of <code>&lt;function0&gt;</code>. It may have been written as:</p>

<pre><code>scala&gt; def foo() = 5
foo: ()Int
</code></pre>

<p>Almost.</p>

<p>Can you spot the difference between these three definitions: <code>def foo = 5</code> and <code>def foo() = 5</code> and <code>val f = foo _</code>?</p>

<p>In Scala, <strong>a function</strong> is <em>always</em> a (object) value of a function type that&rsquo;s a syntactic sugar for a <code>Function</code> trait, e.g. <code>Int =&gt; Boolean</code> corresponds to Function1[Int, Boolean]. As a value the function value can be assigned to a name, i.e. can be named.</p>

<p>On the other hand, <strong>a method</strong> of a class is <em>always</em> a member of the type the class represents and as such doesn&rsquo;t have its own type. It has a signature, though, e.g. <code>()Int</code> that looks like a function type, e.g. <code>() =&gt; Int</code>.</p>

<p>A method <em>always</em> belongs to an instance of a class yet looks similar to a function signature-wise.</p>

<p>Think of a method, say <code>foo</code>, that accepts a value of a function type.</p>

<pre><code>scala&gt; def foo(bar: () =&gt; Int) = bar()
baz: (bar: () =&gt; Int)Int

scala&gt; object A {
     |   def baz() = 5
     | }
defined module A

scala&gt; foo(A.baz)
res13: Int = 5

scala&gt; val ff = A.baz _
ff: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(ff)
res14: Int = 5
</code></pre>

<p>During compilation the call <code>foo(A.baz)</code> was transformed to a call to a function value that in turn calls the method <code>baz</code> on the <code>A</code> sole object. It may have been written as:</p>

<pre><code>scala&gt; val fv: () =&gt; Int = () =&gt; A.baz()
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res15: Int = 5
</code></pre>

<p>The function value <code>fv</code> is of <code>Function0[Int]</code> type.</p>

<pre><code>scala&gt; val fv: Function0[Int] = new Function0[Int] {
     |   def apply() = A.baz()
     | }
fv: () =&gt; Int = &lt;function0&gt;

scala&gt; foo(fv)
res17: Int = 5
</code></pre>

<p>Quoting the answer to <a href="http://stackoverflow.com/a/6651099/1305344">When do I have to treat my methods as partially applied functions in Scala?</a> on StackOverflow:</p>

<blockquote><p>You have to write the <code>_</code> whenever the compiler is not explicitly expecting a <code>Function</code> object.</p></blockquote>

<pre><code>scala&gt; def foo(n: Int) = n
foo: (n: Int)Int

scala&gt; val bar = foo
&lt;console&gt;:8: error: missing arguments for method foo;
follow this method with `_' if you want to treat it as a partially applied function
       val bar = foo
                 ^

scala&gt; val bar: Int =&gt; Int = foo
bar: Int =&gt; Int = &lt;function1&gt;
</code></pre>

<h2>Uniform access principle</h2>

<p>Interestingly, uniform access principle makes understanding eta expansion a bit tricker.</p>

<pre><code>scala&gt; object A {
     |   def foo(bar: () =&gt; Int) = 1
     |   def foo(n: Int) = 2
     | }
defined module A

scala&gt; def f() = 4
f: ()Int

scala&gt; def baz() = 4
baz: ()Int
</code></pre>

<p>Guess what happens when you execute <code>A.foo(baz)</code>.</p>

<pre><code>scala&gt; A.foo(baz)
res0: Int = 2
</code></pre>

<p>What about calling <code>A.foo</code> with <code>baz _</code>?</p>

<pre><code>scala&gt; A.foo(baz _)
res1: Int = 1
</code></pre>

<p>Can you explain why? Visit <a href="http://stackoverflow.com/q/17324247/1305344" title="Eta-expansion between methods and functions with overloaded methods in Scala">Eta-expansion between methods and functions with overloaded methods in Scala</a> on StackOverflow for more information.</p>

<p>There&rsquo;s another example that is not easy to explain.</p>

<pre><code>scala&gt; def fm: Map[Int, String] = Map(0 -&gt; "zero")
fm: Map[Int,String]

scala&gt; fm.isInstanceOf[Function1[Int, String]]
res15: Boolean = true

scala&gt; def g: Int =&gt; String = fm
g: Int =&gt; String
</code></pre>

<p>Since <code>fm</code> is of the <code>Map[Int, String]</code> type and <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Map">scala.collection.immutable.Map</a> inherits from <a href="http://www.scala-lang.org/api/current/index.html#scala.Function1">scala.Function1</a>, one can assign <code>fm</code> to <code>g</code>. That works fine.</p>

<p>Can you explain why the following sample doesn&rsquo;t work?</p>

<pre><code>scala&gt; def fm(): Map[Int, String] = Map(0 -&gt; "zero")
fm: ()Map[Int,String]

scala&gt; def g: Int =&gt; String = fm
&lt;console&gt;:8: error: type mismatch;
 found   : () =&gt; Map[Int,String]
 required: Int =&gt; String
       def g: Int =&gt; String = fm
                              ^
</code></pre>

<p>Note that <code>fm</code> got merely the brackets and they&rsquo;re indeed equal.</p>

<pre><code>scala&gt; fm() == fm
res16: Boolean = true
</code></pre>

<p>See <a href="https://issues.scala-lang.org/browse/SI-7187">SI-7187 eta expansion should not precede empty application</a>.</p>

<h2>Eta expansion and overloaded methods</h2>

<p>When there&rsquo;s an object of a type with overloaded methods the underscore <code>_</code> may yield different results.</p>

<p>It may resolve to a one-or-more-argument method.</p>

<pre><code>scala&gt; object A {
     |   def foo = 5
     |   def foo(n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res6: () =&gt; Int = &lt;function0&gt;
</code></pre>

<p>The underscore insists on specifying the type of a function value when there&rsquo;s ambiguity regarding the method it should be applied to. And it doesn&rsquo;t matter what the order of parameter types in the overloaded methods is.</p>

<pre><code>scala&gt; object A {
     |   def foo(n: Int) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
&lt;console&gt;:9: error: ambiguous reference to overloaded definition,
both method foo in object A of type (n: Int, m: Int)Int
and  method foo in object A of type (n: Int)Int
match expected type ?
              A.foo _
                ^

scala&gt; A.foo _ : ((Int, Int) =&gt; Int)
res5: (Int, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<p>Interestingly, the underscore is more forgiving (regarding the explicit type of the function value) when there are two overloaded methods of which one accepts a single parameter of the type <a href="http://www.scala-lang.org/api/current/scala/AnyRef.html">AnyRef</a>. In such case, the other method - the no-AnyRef method is chosen.</p>

<pre><code>scala&gt; object A {
     |   def foo(a: AnyRef) = 5
     |   def foo(s: String, n: Int) = 10
     | }
defined module A

scala&gt; A.foo _
res5: (String, Int) =&gt; Int = &lt;function2&gt;
</code></pre>

<h2>Use case - Abstracting over arity</h2>

<p>With eta expansion you may forget about the arity of a method.</p>

<pre><code>scala&gt; class A {
     |   def foo(x: Int, y: Int, z: Int) = 5
     | }
defined class A

scala&gt; def bar(x: A) = x.foo _
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>It&rsquo;s certainly far simpler (and still type-safe) than doing it explicitly.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_, _, _)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<p>When there is another three-argument method in the <code>A</code> class, you&rsquo;d need to specify the parameter types explicitly that makes using the approach even more troublesome.</p>

<pre><code>scala&gt; def bar(x: A) = x.foo(_: Int, _: Int, _: Int)
bar: (x: A)(Int, Int, Int) =&gt; Int
</code></pre>

<h2>Scala Specification about Eta Expansion</h2>

<p>In <strong>6.26.5 Eta Expansion</strong> <a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a> says:</p>

<blockquote><p>Eta-expansion converts an expression of method type to an equivalent expression
of function type.</p></blockquote>

<p>The section belongs to <strong>6.26 Implicit Conversions</strong> that gives another perspective on what eta expansion is - it&rsquo;s <em>an implicit converstion</em>.</p>

<p>In <strong>6.26 Implicit Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p>Implicit conversions can be applied to expressions whose type does not match their
expected type, to qualifiers in selections, and to unapplied methods.</p></blockquote>

<p>It goes further into when a type is compatible to another.</p>

<blockquote><p>We say, a type T is compatible to a type U if T conforms to U after applying eta-expansion (§6.26.5) and view applications (§7.3).</p></blockquote>

<p>In <strong>6.26.2 Method Conversions</strong> the Scala Language Specification says:</p>

<blockquote><p><strong>Eta Expansion.</strong> Otherwise, if the method is not a constructor, and the expected
type pt is a function type (Ts&#8217;) => T&#8217;, eta-expansion (§6.26.5) is performed on the
expression e.</p></blockquote>

<h2>References (where wisdom came from)</h2>

<ul>
<li><a href="http://gleichmann.wordpress.com/2011/01/09/functional-scala-turning-methods-into-functions/">Functional Scala: Turning Methods into Functions (or WTF is eta expansion?)</a></li>
<li><a href="https://groups.google.com/d/msg/scala-language/FrDJiagB8CY/3NVmhdKe0vgJ">Eta expansion, meet overloading</a></li>
<li><a href="http://scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">Scala Language Specification (PDF)</a></li>
<li><a href="http://stackoverflow.com/q/17324247/1305344">Eta-expansion between methods and functions with overloaded methods in Scala</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
